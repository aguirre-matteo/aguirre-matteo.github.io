
[{"content":"Hi, I\u0026rsquo;m Aguirre Matteo, a young student from a Tech School in Argentina. I started to use Linux in 2024 and rapidly fell in love with the open source community and decided to become a Linux SysAdmin. I\u0026rsquo;m currently learning all the tools and skills that are needed in a typical job, like managing and configuring services such as DHCPs, DNSs, Web servers, and working with containers.\nI\u0026rsquo;ve studied English for around 2-3 years, but mainly acquired it due to fully immersing myself in the language and only consuming content in that language. I could say I\u0026rsquo;m proficient at reading and writting text in English, but I still have to practice my pronounciation.\nI also self-studied Calculus and other advanced Math topics such as Statistics, Linear Algebra and Differential Equations. I\u0026rsquo;ve a great foundation in Algebra, which made it easier to learn those topics.\nI store all my knowledge in the form of a blog in my personal website, so feel free to take a look at it! If you\u0026rsquo;re looking for someone focused in learning and doing the job the right way, then you\u0026rsquo;re in the right place.\nEmail: aguirre-matteo@proton.me Website: https://aguirre-matteo.github.io/ Tech Stack # Programming Languages # DevOps # Operating Systems # Coming soon # ","externalUrl":null,"permalink":"/","section":"Aguirre Matteo's personal website","summary":"","title":"Aguirre Matteo's personal website","type":"page"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/blog/","section":"Blog","summary":"","title":"Blog","type":"blog"},{"content":"","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":" Overview # RAID is a powerful solution to data redundancy and performance improvement for disks, which allows us to create a pool of storage devices to ensure fault tolerance, improve I/O operations or unify their capacity into a single logical volume. In this article, you\u0026rsquo;ll learn how to configure RAID from scratch on your Linux server using the mdadm tool. We\u0026rsquo;ll also cover the different types of RAIDs and the use case for each one.\nRequirements # For this guide, you should have installed the mdadm package, which provides the utilities for working with RAID on Linux.\nOn Debian/Ubuntu, the command to install it is:\nsudo apt install mdadm Or on Fedora/RHEL based environment, the command is:\nsudo dnf install mdadm What is RAID? # RAID (Redundant Array of Independent Disks) is a technology that combines multiple physical storage devices into a single unit, with the goal to improve data redundancy (to prevent data loss) and to improve the performance of read/write operations. RAID can be done both via software or hardware, but hardware RAID is beyond the scope of this guide.\nLevels # There are different \u0026ldquo;levels\u0026rdquo; or configurations of RAID, with each one offering distinct benefits. The most commonly used are RAID 0, 1, 5 and 6.\nRAID 0 (Striping) # This level focuses entirely on improving performance. The data is split into \u0026ldquo;stripes\u0026rdquo; which are distributed equally across all the disks. This improves both the read and write speeds, since operations can be done in parallel. The main drawback of this level is that, if one disk is damaged/corrupted, all the information will be lost. It\u0026rsquo;s mainly used when data loss is not a big concern.\nRAID 1 (Mirroring) # This configuration ensures data redundancy, preventing data loss. It works duplicating the data on all the drives, so if one of the disks fail there\u0026rsquo;s an exact copy of the file on the other drives. This improves read performance, since data can be read in parallel. The principal disadvantage of RAID 1 is that the storage capacity is limited to the capacity of a single disk. Also, the write speed might be slower. It\u0026rsquo;s the best for critical systems where the data must be secured and available at any moment.\nRAID 5 (Striping with distributed parity) # Just like RAID 0, this level splits the data across all the disks, but it adds the concept of a \u0026ldquo;parity block\u0026rdquo;, a checksum that makes it possible to reconstruct the original data in case a disk fails. It offers a good balance of performance, redundancy and capacity, since data can be read/written in parallel, it has a fault tolerance mechanism and the total capacity is (N-1) disks where N is the amount of disks we are using. The downside of this level is that the write speed is considerably slower, since the CPU needs to calculate the parity blocks. It\u0026rsquo;s best suited for general purpose servers, where balance is preferred.\nRAID 6 (Striping with double distributed parity) # It\u0026rsquo;s an extended version of RAID 5 which adds a parity block making it able to withstand the failure of two storage devices simultaneously without losing data. The write speed gets even slower than with RAID 5. The total capacity will be (N-2), so we\u0026rsquo;ll be losing the capacity of two disks.\nCreating a RAID # Now it\u0026rsquo;s time to learn how to actually create a RAID. First of all, we have to identify the name of the disks we want to be part of the array. In my case, I have four virtual disks:\nmyuser@deb-homelab:~# lsblk NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINTS vda 254:0 0 5G 0 disk vdb 254:16 0 5G 0 disk vdc 254:32 0 5G 0 disk vdd 254:48 0 5G 0 disk If I want to make a RAID 0 using vda and vdb, I should run:\nroot@deb-homelab:~# mdadm --create /dev/md/myraid0 --level=0 --raid-devices=2 /dev/vda /dev/vdb mdadm: Defaulting to version 1.2 metadata mdadm: array /dev/md/myraid0 started. root@deb-homelab:~# mdadm: is the RAID software for Linux. --create: this tells mdadm that we want to create a RAID. /dev/md/myraid0: is the name we are giving to this new array. Make sure it starts with /dev/md. --level=0: sets the level of the RAID. In this case we want to generate a RAID 0. --raid-devices=2: how much disks we\u0026rsquo;ll use in the array. /dev/vda /dev/vdb: the disks to use in the RAID. We can verify our RAID was successfully created running:\nroot@deb-homelab:~# cat /proc/mdstat Personalities : [raid0] md127 : active raid0 vdc[1] vdb[0] 10475520 blocks super 1.2 512k chunks unused devices: \u0026lt;none\u0026gt; root@deb-homelab:~# Now, let\u0026rsquo;s create a RAID 5! First I\u0026rsquo;ll do will be to delete the RAID we\u0026rsquo;ve just made:\nroot@deb-homelab:~# mdadm --stop /dev/md/myraid0 mdadm: stopped /dev/md/myraid0 root@deb-homelab:~# A good practice would be to also delete the RAID superblocks from those devices, to prevent the operating system from thinking they are part of a RAID.\nroot@deb-homelab:~# mdadm --zero-superblock /dev/vdb /dev/vdc root@deb-homelab:~# And now, to create the RAID 5, all we have to do is to change the --level flag to 5:\nroot@deb-homelab:~# mdadm --create /dev/md/myraid5 --level=5 --raid-devices=4 /dev/vdb /dev/vdc /dev/vdd /dev/vde mdadm: Defaulting to version 1.2 metadata mdadm: array /dev/md/myraid5 started. root@deb-homelab:~# apt install htop Reading package lists... Done root@deb-homelab:~# cat /proc/mdstat Personalities : [raid0] [raid6] [raid5] [raid4] md127 : active raid5 vde[4] vdd[2] vdc[1] vdb[0] 15713280 blocks super 1.2 level 5, 512k chunk, algorithm 2 [4/4] [UUUU] unused devices: \u0026lt;none\u0026gt; root@deb-homelab:~# Nested RAID # A nested RAID is a configuration where two or more RAID levels are combined to achieve a better balance or performance than what a single RAID could offer. In essence, a nested RAID could be interpreted as a \u0026ldquo;RAID of RAIDs\u0026rdquo;. A common example of this is RAID 10 (1+0), which strips the data across mirrored pairs of disks, giving us the write speed boost of RAID 0, while also the fault tolerance of RAID 1, since the data is mirrored.\nRAID 50 (5+0) is another nested RAID configuration, which divides the data through an array of RAID 5s, combining the inherit speed boost of RAID 0, with the space-efficient fault tolerance of distributed parity. This configuration in particular resists the failure of one disk per RAID 5 in the array.\nCreating a nested RAID # We can build a nested RAID just by changing the storage devices we pass to mdadm --create with RAID devices. For example, to create a RAID 10, I\u0026rsquo;ll first create two RAID 1s, and then I\u0026rsquo;ll make a RAID 0 passing those RAIDs as arguments:\nroot@deb-homelab:~# mdadm --create /dev/md/raid1a --level=1 --raid-devices=2 /dev/vdb /dev/vdc mdadm: array /dev/md/raid1a started. root@deb-homelab:~# mdadm --create /dev/md/raid1b --level=1 --raid-devices=2 /dev/vdd /dev/vde mdadm: array /dev/md/raid1b started. root@deb-homelab:~# mdadm --create /dev/md/raid10 --level=0 --raid-devices=2 /dev/md/raid1a /dev/md/raid1b mdadm: Defaulting to version 1.2 metadata mdadm: array /dev/md/raid10 started. root@deb-homelab:~# Now if we see the contents of /proc/mdstat, we\u0026rsquo;ll notice there are three devices, and one of them is made of the other two RAIDs:\nroot@deb-homelab:~# cat /proc/mdstat Personalities : [raid6] [raid5] [raid4] [linear] [multipath] [raid0] [raid1] [raid10] md125 : active raid0 md126[1] md127[0] 10465280 blocks super 1.2 512k chunks md126 : active raid1 vde[1] vdd[0] 5237760 blocks super 1.2 [2/2] [UU] md127 : active raid1 vdc[1] vdb[0] 5237760 blocks super 1.2 [2/2] [UU] unused devices: \u0026lt;none\u0026gt; root@deb-homelab:~# The same would apply for any other kind of nested RAID. For instance, to create a RAID 51 we\u0026rsquo;ll do:\nroot@deb-homelab:~# mdadm --create /dev/md/raid5a --level=5 --raid-devices=3 /dev/vdb /dev/vdc /dev/vdd mdadm: array /dev/md/raid5a started. root@deb-homelab:~# mdadm --create /dev/md/raid5b --level=5 --raid-devices=3 /dev/vde /dev/vdf /dev/vdg mdadm: array /dev/md/raid5b started. root@deb-homelab:~# mdadm --create /dev/md/raid51 --level=1 --raid-devices=2 /dev/md/raid5a /dev/md/raid5b mdadm: array /dev/md/raid51 started. Conclusion # This guide explains the fundamental ideas behind RAID and how to create your own using Linux and mdadm. If you find this page useful, feel free to share it with someone else. Have a nice day!\n","externalUrl":null,"permalink":"/blog/linux/raid/","section":"Blog","summary":"","title":"Configure RAID in your server with mdadm","type":"blog"},{"content":"","externalUrl":null,"permalink":"/tags/cryptsetup/","section":"Tags","summary":"","title":"Cryptsetup","type":"tags"},{"content":"","externalUrl":null,"permalink":"/tags/crypttab/","section":"Tags","summary":"","title":"Crypttab","type":"tags"},{"content":"","externalUrl":null,"permalink":"/tags/encryption/","section":"Tags","summary":"","title":"Encryption","type":"tags"},{"content":"","externalUrl":null,"permalink":"/tags/file-sharing/","section":"Tags","summary":"","title":"File Sharing","type":"tags"},{"content":"","externalUrl":null,"permalink":"/tags/ftp/","section":"Tags","summary":"","title":"Ftp","type":"tags"},{"content":" Overview # SSH (Secure SHell) is a protocol designed to securely communicate with a remote computer. It validates the identity of user and encrypts all the data is sent between the devices. It\u0026rsquo;s widely used to run commands on a server over the internet and transfer files in a secure way. In this guide, I\u0026rsquo;ll show you how to install SSH, configure it, and how you can use it to connect to your servers.\nBasic Syntax # The basic syntax for using the SSH command is as follows:\nssh [username]@[ip-address] Where we replace username with your remote server username, and ip-address with the server\u0026rsquo;s IP address.\nSetup # Installation # Depending if we\u0026rsquo;re on our server, or on our local machine, we have to install the openssh-server and openssh-client packages respectively.\nIn the case of Debian/Ubuntu-based system, we open the terminal and run:\nsudo apt install openssh-server sudo apt install openssh-client Or if we are using RHEL or a derivative, we run instead:\nsudo dnf install openssh-server sudo dnf install openssh-clients Then we should start the SSH service on our server. We do so running the following commands:\nsudo systemctl enable ssh # Enables the service, starting at system boot. sudo systemctl start ssh # Manually starts the service. If we have a firewall enabled, we should also open the port 22, so we can reach our SSH server. For example, if we\u0026rsquo;re using ufw, we can open the port running this command:\n# UFW will translate SSH to port 22 sudo ufw allow ssh Server Configuration # Now that we have installed SSH, it\u0026rsquo;s time to tweak its config file. We can find it at /etc/ssh/sshd_config. It provides a large number of options which we can find in the manual running man sshd_config. Here I show you an example configuration, which modifies the most commonly used options:\n# Which port SSH should use. It\u0026#39;s highly recommended keeping it # at 22, since it could break your setup. Port 22 # Prevents the clients from login as root. Keep this at false, # and use sudo instead when needed. PermitRootLogin no # Enables Public Key Authentication, making it posible to login # using a SSH key instead of using a password. PubkeyAuthentication, yes # You\u0026#39;ll only be able to auth to your server using SSH keys. # Make sure you add your keys before disabling this. PasswordAuthentication no # Users the clients are allowed to login as. # Other users will be disabled. AllowUsers myssh-user another_user AllowGroups ssh_users # Users the clients shouldn\u0026#39;t be able to login as. # Other users will be enabled. DenyUsers root DenyGroups important_users After editing the file, we should restart the SSH service running sudo systemctl restart ssh.\nRemote Access # Now that our server is configured, we can connect to it using the ssh command. In this example, I access a Debian virtual machine:\n[matteo@nixos:~]$ ssh myssh-user@192.160.122.230 myssh-user@192.160.122.230\u0026#39;s password: Linux deb-homelab 6.1.0-37-amd64 #1 SMP PREEMPT_DYNAMIC Debian 6.1.140-1 (2025-05-22) x86_64 The programs included with the Debian GNU/Linux system are free software; the exact distribution terms for each program are described in the individual files in /usr/share/doc/*/copyright. Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extent permitted by applicable law. Last login: Sat May 31 15:56:13 2025 from 192.160.122.13 myssh-user@deb-homelab:~$ Add your username in place of myssh-user and add your server\u0026rsquo;s IP in place of 192.160.122.230, and enter the password of the user you specified.\nIf it\u0026rsquo;s the first time you\u0026rsquo;re connecting to the server, you\u0026rsquo;ll be prompted to verify the server\u0026rsquo;s authenticity, seeing a message like this:\nThe authenticity of host \u0026#39;192.160.122.230 (192.160.122.230)\u0026#39; can\u0026#39;t be established. ECDSA key fingerprint is SHA256:ontibF1aG+nkeuyXhEO4zKJFfcWgJoX9TVUUdzdENk. Are you sure you want to continue connecting (yes/no/[fingerprint])? We have to type yes and press Enter, then the server will be added to our list of known hosts.\nSSH Keys # SSH keys are a more powerful method to authenticate to your servers, making your connection more secure and allowing to log in without being asked for the password. To use SSH keys we first have to generate a public-private key pair. To do so we use the ssh-keygen command. We\u0026rsquo;ll be prompted to enter the path where we want to save the key pair. I\u0026rsquo;ll save mine at ~/.ssh/ and call it myserver.\n[matteo@nixos:~]$ ssh-keygen Generating public/private ed25519 key pair. Enter file in which to save the key (/home/matteo/.ssh/id_ed25519): /home/matteo/.ssh/myserver Enter passphrase for \u0026#34;/home/matteo/.ssh/myserver\u0026#34; (empty for no passphrase): Enter same passphrase again: Your identification has been saved in /home/matteo/.ssh/myserver Your public key has been saved in /home/matteo/.ssh/myserver.pub The key fingerprint is: SHA256:lNjTQHE+ojhhdlI9BwoGJKgpt/AjQPNJEtgIUmkI9sQ matteo@nixos The key\u0026#39;s random art image is: +--[ED25519 256]--+ |XO*+o .o=o. | |B=*E o +o*. | |oo=.* + *o+ | |* .= = o o . | |o+ .o . S | |. + . | | . . | | | | | +----[SHA256]-----+ [matteo@nixos:~]$ If we want, we can enter a passphrase for our private key, enhancing the security of the connection. Otherwise, leave it empty. Now it\u0026rsquo;s time to add our keys to our server using the ssh-copy-id command.\n[matteo@nixos:~]$ ssh-copy-id -i ~/.ssh/myserver myssh-user@192.160.122.230 /run/current-system/sw/bin/ssh-copy-id: INFO: Source of key(s) to be installed: \u0026#34;/home/matteo/.ssh/myserver.pub\u0026#34; /run/current-system/sw/bin/ssh-copy-id: INFO: attempting to log in with the new key(s), to filter out any that are already installed /run/current-system/sw/bin/ssh-copy-id: INFO: 1 key(s) remain to be installed -- if you are prompted now it is to install the new keys myssh-user@192.160.122.230\u0026#39;s password: Number of key(s) added: 1 Now try logging into the machine, with: \u0026#34;ssh -i /home/matteo/.ssh/myserver \u0026#39;myssh-user@192.160.122.230\u0026#39;\u0026#34; and check to make sure that only the key(s) you wanted were added. [matteo@nixos:~]$ We enter the password for the last time, and then it\u0026rsquo;ll print in the screen that our keys were successfully added. Now we can connect to our server using the -i flag, followed by the path to the key.\n[matteo@nixos:~]$ ssh -i ~/.ssh/myserver myssh-user@192.160.122.230 Linux deb-homelab 6.1.0-37-amd64 #1 SMP PREEMPT_DYNAMIC Debian 6.1.140-1 (2025-05-22) x86_64 The programs included with the Debian GNU/Linux system are free software; the exact distribution terms for each program are described in the individual files in /usr/share/doc/*/copyright. Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extent permitted by applicable law. Last login: Sun Jun 1 18:39:37 2025 myssh-user@deb-homelab:~$ And voila! We weren\u0026rsquo;t prompted for entering the password!\nFile Transfer # SSH allows us to access the filesystem of our remote server in a safe way, encrypting the files, ensuring no one without permissions can read the contents. We\u0026rsquo;ll use the scp and sftp commands to take advantage of SSH\u0026rsquo;s features to work with our server\u0026rsquo;s files.\nSCP # STP stands for Secure Copy and, as the name suggests, scp is an extended version of the cp command which can be used to copy files from our server. The syntax of scp is the same as the cp command:\nscp [from] [to] Where both from and to can be in an extended form of SSH\u0026rsquo;s target syntax, which uses a : to specify the path:\n[username]@[ip-address]:/path/to/file For example, if we want to copy a shell script to our server, we\u0026rsquo;ll do something like this:\n[matteo@nixos:~]$ scp ./bash-script.sh \\ myssh-user@192.160.122.230:/home/myssh-user/scripts/ \\ -i /home/matteo/.ssh/myserver bash-script.sh 100% 83 26.7KB/s 00:00 [matteo@nixos:~]$ Since we\u0026rsquo;re using an SSH key to connect to the server, we weren\u0026rsquo;t prompted to enter the password. We can also copy entire directories using the -r flag. For example, if we want to copy all the logs from the server to our computer, we do the following:\n[matteo@nixos:~]$ scp -r myssh-user@192.160.122.230:/var/log/ ./logs \\ -i /home/matteo/.ssh/myserver [matteo@nixos:~]$ ls log/ alternatives.log dpkg.log fontconfig.log private alternatives.log.1 dpkg.log.1 installer README alternatives.log.2.gz dpkg.log.2.gz journal runit apt faillog lastlog wtmp [matteo@nixos:~]$ SFTP # SFTP stands for Secure File Transfer Protocol. It\u0026rsquo;s an improved version of the FTP protocol to use SSH to encrypt the communication, and it allows us to interactively access the remote filesystem providing commands like ls, cd, mkdir, rm, among others. To use it we have to run sftp and pass our server as the argument:\n[matteo@nixos:~]$ sftp myssh-user@192.168.122.160 \\ -i /home/matteo/.ssh/myserver Connected to 192.168.122.160. sftp\u0026gt; By default, sftp will put us in the user\u0026rsquo;s home directory. We can verify so typing pwd in the new shell:\nsftp\u0026gt; pwd Remote working directory: /home/myssh-user sftp\u0026gt; I have some Markdown files that I want to copy to the server. To do so we can use the put command, followed by the name of the files. Some commands related to the FS can be executed locally prefixing them with the letter l, such as ls, cd, mkdir, pwd and umask.\nsftp\u0026gt; lls nixos-hardware.md ssh-tutorial.md sftp\u0026gt; put nixos-hardware.md Uploading nixos-hardware.md to /home/ami/nixos-hardware.md nixos-hardware. 100% 0 0.0KB/s 00:00 sftp\u0026gt; put ssh-tutorial.md Uploading ssh-tutorial.md to /home/ami/ssh-tutorial.md ssh-tutorial. 100% 0 0.0KB/s 00:00 sftp\u0026gt; ls nixos-hardware.md ssh-tutorial.md sftp\u0026gt; Now if for some reason I\u0026rsquo;ve lost those files, I can copy them back with the get command.\nsftp\u0026gt; lls sftp\u0026gt; get nixos-hardware.md Fetching /home/ami/nixos-hardware.md to nixos-hardware.md sftp\u0026gt; get ssh-tutorial.md Fetching /home/ami/ssh-tutorial.md to ssh-tutorial.md sftp\u0026gt; lls nixos-hardware.md ssh-tutorial.md sftp\u0026gt; To see all the available commands in sftp we can type help and press enter.\nClient Configuration # We may face some situations where we are constantly accessing to the same server, and it becomes repetitive to write the same username and IP address over and over again. To those cases, SSH allows up to create a config file under ~/.ssh/config to declare our servers, so we can use an alias instead of running the entire command. These declarations use the following syntax:\nHost \u0026lt;alias\u0026gt; Hostname \u0026lt;ip-address\u0026gt; User \u0026lt;username\u0026gt; IdentityFile \u0026lt;path\u0026gt; ... Host \u0026lt;alias\u0026gt; Hostname \u0026lt;ip-address\u0026gt; User \u0026lt;username\u0026gt; IdentityFile \u0026lt;path\u0026gt; ... In our example, we could declare the server and call it myserver, setting the IP address, the username and the path to the SSH key respectively:\nHost myserver Hostname 192.160.122.230 User myssh-user IdentityFile /home/matteo/.ssh/myserver So now we can simply pass myserver as the argument to ssh and it will automatically translate the alias to the real target and will use our key.\n[matteo@nixos:~]$ ssh myserver Linux deb-homelab 6.1.0-37-amd64 #1 SMP PREEMPT_DYNAMIC Debian 6.1.140-1 (2025-05-22) x86_64 The programs included with the Debian GNU/Linux system are free software; the exact distribution terms for each program are described in the individual files in /usr/share/doc/*/copyright. Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extent permitted by applicable law. Last login: Fri Jun 6 18:17:48 2025 myssh-user@deb-homelab:~$ Conclusion # In this article I\u0026rsquo;ve showed all you need to know to start using SSH to connect to your servers. It covers how to connect to your servers, install and configure a SSH server, how to use SSH keys to authenticate and how to transfer files from one machine to another. If you find this article useful, feel free to share it to someone else or recommend my page. Have a nice day!\n","externalUrl":null,"permalink":"/blog/linux/ssh/","section":"Blog","summary":"","title":"How to use SSH from scratch","type":"blog"},{"content":"","externalUrl":null,"permalink":"/categories/linux/","section":"Categories","summary":"","title":"Linux","type":"categories"},{"content":"","externalUrl":null,"permalink":"/tags/luks/","section":"Tags","summary":"","title":"Luks","type":"tags"},{"content":"","externalUrl":null,"permalink":"/tags/mdadm/","section":"Tags","summary":"","title":"Mdadm","type":"tags"},{"content":"","externalUrl":null,"permalink":"/tags/network/","section":"Tags","summary":"","title":"Network","type":"tags"},{"content":"","externalUrl":null,"permalink":"/tags/performance/","section":"Tags","summary":"","title":"Performance","type":"tags"},{"content":"","externalUrl":null,"permalink":"/tags/privacy/","section":"Tags","summary":"","title":"Privacy","type":"tags"},{"content":" Overview # Securing our private data from a bare-metal attack is extremely important if we want to ensure privacy. This is especially the case on laptops, since they\u0026rsquo;re in constant exposure to the external world, and on enterprise and governmental computers, where a leak of information could compromise the personal data of a large number of persons. LUKS is currently the most powerful and widely adopted solution for disk encryption on Linux. In this guide I\u0026rsquo;ll show you how to use LUKS to encrypt your disks, how to configure it to automatically mount on boot, and how to manage different passphrases to unlock the partition.\nRequirements # Before continuing with the guide, we should first install the cryptsetup package, which provides the utilities for managing LUKS.\nIf we are using Debian/Ubuntu we must run:\nsudo apt install cryptsetup Or in the case we\u0026rsquo;re using a Fedora/RHEL derivative:\nsudo dnf install cryptsetup-luks We\u0026rsquo;ll also be using parted for partitioning the disk, so make sure you have it installed, or use your prefered tool.\nsudo apt install parted # Debian/Ubuntu sudo dnf install parted # Fedora/RHEL Creating an encrypted partition # Open the terminal and find which disk/partition you want to encrypt. In my case, I have two virtual disks, vda and vdb, and I\u0026rsquo;ll use the last to store my sensitive data.\n[root@nixos:~]$ lsblk NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINTS vda 253:0 0 20G 0 disk ├─vda1 253:1 0 1.9G 0 part └─vda2 253:2 0 18.1G 0 part vdb 253:16 0 20G 0 disk The first step is to format the disk/partition as a LUKS device. To do so we have to run cryptsetup luksFormat /dev/disk and set the passphrase we want to use to protect the data.\n[root@nixos:~]$ cryptsetup luksFormat /dev/vdb WARNING! ======== This will overwrite data on /dev/vdb irrevocably. Are you sure? (Type \u0026#39;yes\u0026#39; in capital letters): YES Enter passphrase for /dev/vdb: Verify passphrase: [root@nixos:~]$ This completely wiped the disk, so all the data that was there now is lost. To start working with it, we have to unlock the device using the cryptsetup open command.\n[root@nixos:~]$ cryptsetup open /dev/vdb encrypted-disk Enter passphrase for /dev/vdb: [root@nixos:~]$ I\u0026rsquo;ll call it encrypted-disk so it\u0026rsquo;s more easy to recognize it. Now the device is available under /dev/mapper/encrypted-disk. Replace the last part with the name you gave. I\u0026rsquo;ll format it as a BTRFS filesystem and mount it at /mnt\n[root@nixos:~]$ mkfs.btrfs /dev/mapper/encrypted-disk btrfs-progs v6.11 See https://btrfs.readthedocs.io for more information. NOTE: several default settings have changed in version 5.15, please make sure this does not affect your deployments: - DUP for metadata (-m dup) - enabled no-holes (-O no-holes) - enabled free-space-tree (-R free-space-tree) Label: (null) UUID: 35cf0855-f5d6-4fe8-b773-808bbefb8493 Node size: 16384 Sector size: 4096\t(CPU page size: 4096) Filesystem size: 19.98GiB Block group profiles: Data: single 8.00MiB Metadata: DUP 256.00MiB System: DUP 8.00MiB SSD detected: no Zoned device: no Features: extref, skinny-metadata, no-holes, free-space-tree Checksum: crc32c Number of devices: 1 Devices: ID SIZE PATH 1 19.98GiB /dev/mapper/encrypted-disk [root@nixos:~]$ mount /dev/mapper/encrypted-disk /mnt/ [root@nixos:~]$ And if we want to umount it, we should run umount and cryptsetup close.\n[root@nixos:~]$ umount /mnt [root@nixos:~]$ cryptsetup close encrypted-disk [root@nixos:~]$ Mounting on boot # Cryptsetup has it own fstab-like config file where we can declare all the encrypted devices we want to unlock during the boot. We can find it at /etc/crypttab and the syntax of each line is like it follows:\nvolume-name device key-file options In our example, I should configure it like this, using the UUID of the disk to identify it. We can get the UUID running cryptsetup luksUUID.\n[root@nixos:~]$ cryptsetup luksUUID /dev/vdb 283c80cf-04ee-42f4-afe8-4b51bc124498 On /etc/crypttab:\nencrypted-disk UUID=283c80cf-04ee-42f4-afe8-4b51bc124498 none luks Now we add an entry to /etc/fstab to mount it automatically on boot:\n/dev/mapper/encrypted-disk /mnt btrfs defaults 0 2 And the last step is to update the initram so the changes are applied:\nupdate-initramfs -u -k all Managing passphrases # LUKS permits us to set multiple keys to unlock the encrypted disk, allowing for more flexibility. Cryptsetup provides commands for both adding and removing passphrases from the disk.\nAdd key # To add a new passphrase to our setup, we can use the cryptsetup luksAddKey command, followed by the device we want to modify.\n[root@nixos:~]$ cryptsetup luksAddKey /dev/vda Enter any existing passphrase: Enter new passphrase for key slot: Verify passphrase: [root@nixos:~]$ It will prompt us to enter the already existent passphrase we\u0026rsquo;ve set up, and the new passphrases we want to add.\nRemove key # To remove a passphrase from the LUKS device, we use cryptsetup luksRemoveKey and pass the device as the argument.\n[root@nixos:~]$ cryptsetup luksRemoveKey /dev/vda Enter passphrase to be deleted: [root@nixos:~]$ It will ask us for the passphrase we want to remove and it will delete it from the list.\nConclusion # In this article I\u0026rsquo;ve showed you all the commands related to LUKS you need to know to encrypt a disk to protect sensitive data. If you find this guide useful, feel free to share it to other people or recommend the page. Have a nice day!\n","externalUrl":null,"permalink":"/blog/linux/luks/","section":"Blog","summary":"","title":"Protecting your files with LUKS","type":"blog"},{"content":"","externalUrl":null,"permalink":"/tags/raid/","section":"Tags","summary":"","title":"Raid","type":"tags"},{"content":"","externalUrl":null,"permalink":"/tags/remote-access/","section":"Tags","summary":"","title":"Remote-Access","type":"tags"},{"content":"","externalUrl":null,"permalink":"/tags/security/","section":"Tags","summary":"","title":"Security","type":"tags"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","externalUrl":null,"permalink":"/tags/server/","section":"Tags","summary":"","title":"Server","type":"tags"},{"content":" Overview # FTP (File Transfer Protocol) is an Internet protocol used to transfer files between different machines over a network. It follows the client-server model where a client installs an FTP client app to connect to a remote FTP server. In this guide, you\u0026rsquo;ll learn how to setup your own FTP server and access it through different clients.\nSecurity concerns # The FTP protocol is in disuse due to some major security issues, like the lack of encryption, vulnerable to brute-force attacks since it doesn\u0026rsquo;t have stronger authentication mechanism than usernames and passwords, and being susceptible to DDoS attacks. In most cases it\u0026rsquo;s highly recommended to use more secure alternatives like SFTP or FTPS, so take this post just as an educational piece of information, and don\u0026rsquo;t follow the steps if you are setting up a sever in production.\nSetup # Installation # The first thing we should do is to install the vsftpd package, which we can do running:\nIn Debian/Ubuntu distributions:\nsudo apt install vsftpd Or on RedHat-based systems:\nsudo dnf install vsftpd The server should start automatically, but if that\u0026rsquo;s not the case we can start it manually doing:\nsudo systemctl enable vsftpd sudo systemctl start vsftpd And of course, if we have previously configured a firewall, we have to open ports 20 and 21:\nsudo ufw allow 20/tcp sudo ufw allow 21/tcp Configuration # In my case, I\u0026rsquo;ll configure the server to allow accessing both with a username and a password, and anonymously. First, let\u0026rsquo;s create the users we want to expose through the server. I\u0026rsquo;ll call them teachers and lab-students:\nsudo useradd -m teachers sudo useradd -m lab-students sudo passwd teachers sudo passwd lab-students And setup the directories we\u0026rsquo;ll serve:\nmkdir -p /srv/ftp/public chmod 555 /srv/ftp/public chown ftp:ftp /srv/ftp/public mkdir -p /home/{lab-students,teachers}/ftp chmod 755 /home/{lab-students,teachers}/ftp chown lab-students:lab-students /home/lab-students/ftp chown teachers:teachers /home/teachers/ftp Now, let\u0026rsquo;s open /etc/vsftpd.conf and write the following lines to the file:\n# Enable anonymous access anonymous_enable=YES no_anon_password=YES # Setup the public directory as read-only anon_root=/srv/ftp/public anon_upload_enable=NO anon_mkdir_write_enable=NO anon_other_write_enable=NO # Vsftpd will replace this token with the respective username user_sub_token=$USER # The directory the daemon must serve local_root=/home/$USER/ftp # This allows logging in as local users local_enable=YES # Gives clients write permissions write_enable=YES # Makes sure users don\u0026#39;t access each others files chroot_local_user=YES # Configures the list of users we\u0026#39;ll allow logging in as userlist_enable=YES # Deny accessing as any other users userlist_deny=NO And in /etc/vsftpd.user_list we write the usernames:\nteachers lab-students And finally restart the service so it reloads the configuration:\nsudo systemctl restart vsftpd Connecting to the server # Now, to connect to our FTP server we must use an FTP client software. There are GUI frontends out there, like Filezilla and WinSCP, but I\u0026rsquo;ll use a CLI client called lftp, which we can install running:\nsudo apt install lftp # Debian/Ubuntu sudo dnf install lftp # Fedora/RHEL We run lftp followed by the IP address of our remote server and we\u0026rsquo;ll be connected to it.\n[matteo@nixos:~]$ lftp 192.168.122.2 lftp 192.168.122.2:~\u0026gt; By default, we\u0026rsquo;ll login anonymously, so if try to list the contents of the current directory, it will show the public available files:\nlftp 192.168.122.2:~\u0026gt; ls -rw-r--r-- 1 0 0 31 Aug 23 14:24 my.txt -rw-r--r-- 1 0 0 26 Aug 23 14:24 public.txt -rw-r--r-- 1 0 0 26 Aug 23 14:24 files.txt lftp 192.168.122.2:~\u0026gt; Now to login as a specific user we type login followed by the username. We\u0026rsquo;ll be prompted to enter it\u0026rsquo;s respective password.\nlftp 192.168.122.2:~\u0026gt; login teachers Password: lftp teachers@192.168.122.2:~\u0026gt; The FTP shell provides commands such as mkdir, rmdir, put and get which we can use to perform those respective operations in the filesystem.\nlftp teachers@192.168.122.2:~\u0026gt; ls -rw-r--r-- 1 0 0 31 Aug 23 14:24 another.txt -rw-r--r-- 1 0 0 26 Aug 23 14:24 message.txt lftp teachers@192.168.122.2:~\u0026gt; mkdir a b c mkdir ok, 3 directories created lftp teachers@192.168.122.2:~\u0026gt; get message.txt 26 bytes transferred lftp teachers@192.168.122.2:~\u0026gt; put ./local.txt 7048 bytes transferred lftp teachers@192.168.122.2:~\u0026gt; ls drwx------ 2 1001 1001 4096 Aug 23 14:25 a -rw-r--r-- 1 0 0 31 Aug 23 14:24 another.txt drwx------ 2 1001 1001 4096 Aug 23 14:25 b drwx------ 2 1001 1001 4096 Aug 23 14:25 c -rw------- 1 1001 1001 0 Aug 23 14:26 local.txt -rw-r--r-- 1 0 0 26 Aug 23 14:24 message.txt lftp teachers@192.168.122.2:~\u0026gt; exit [matteo@nixos:~]$ cat ./message.txt Hello from my FTP server! [matteo@nixos:~]$ All the available commands can be found running help in the FTP shell.\nConclusion # This guides briefly shows how to setup a simple FTP server from scratch, covering how to configurate different users and how to connect to the server via a CLI FTP client. If you find this guide useful, feel free to share it to somebody else or recommend the page. Have a nice day!\n","externalUrl":null,"permalink":"/blog/linux/ftp/","section":"Blog","summary":"","title":"Sharing files across the network with FTP","type":"blog"},{"content":"","externalUrl":null,"permalink":"/tags/ssh/","section":"Tags","summary":"","title":"Ssh","type":"tags"},{"content":"","externalUrl":null,"permalink":"/tags/storage/","section":"Tags","summary":"","title":"Storage","type":"tags"},{"content":"","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","externalUrl":null,"permalink":"/tags/vsftpd/","section":"Tags","summary":"","title":"Vsftpd","type":"tags"}]